"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/contracts/deployments directory to retrieve
  deployment information for CipherBoard.sol:

  - <root>/client/abi/CipherBoardABI.ts
  - <root>/client/abi/CipherBoardAddresses.ts
*/
import { CipherBoardAddresses } from "@/abi/CipherBoardAddresses";
import { CipherBoardABI } from "@/abi/CipherBoardABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type SecureCommunicationType = {
  id: number;
  sender: string;
  recipient: string;
  content: string | null; // null if not decrypted
  transmissionTime: number;
  isDecrypted: boolean;
};

type CipherBoardInfoType = {
  abi: typeof CipherBoardABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves CipherBoard contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `contracts`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getCipherBoardByChainId(chainId);
 */
function getCipherBoardByChainId(
  chainId: number | undefined
): CipherBoardInfoType {
  if (!chainId) {
    return { abi: CipherBoardABI.abi };
  }

  const entry =
    CipherBoardAddresses[chainId.toString() as keyof typeof CipherBoardAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: CipherBoardABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: CipherBoardABI.abi,
  };
}

/*
 * Main CipherBoard React hook for encrypted secure communications
 */
export const useCipherBoard = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [communications, setCommunications] = useState<SecureCommunicationType[]>([]);
  const [decryptedContents, setDecryptedContents] = useState<Map<number, string>>(new Map());
  const [totalCommunications, setTotalCommunications] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isTransmitting, setIsTransmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const cipherBoardRef = useRef<CipherBoardInfoType | undefined>(undefined);
  const isLoadingRef = useRef<boolean>(isLoading);
  const isTransmittingRef = useRef<boolean>(isTransmitting);
  const isDecryptingRef = useRef<boolean>(isDecrypting);

  //////////////////////////////////////////////////////////////////////////////
  // CipherBoard Contract
  //////////////////////////////////////////////////////////////////////////////

  const cipherBoard = useMemo(() => {
    const c = getCipherBoardByChainId(chainId);

    cipherBoardRef.current = c;

    if (!c.address) {
      setMessage(`CipherBoard deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Instance
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!cipherBoard) {
      return undefined;
    }
    return (Boolean(cipherBoard.address) && cipherBoard.address !== ethers.ZeroAddress);
  }, [cipherBoard]);

  const contractInstance = useMemo(() => {
    if (!cipherBoard.address || !ethersReadonlyProvider) {
      return undefined;
    }
    return new ethers.Contract(
      cipherBoard.address,
      cipherBoard.abi,
      ethersReadonlyProvider
    );
  }, [cipherBoard.address, cipherBoard.abi, ethersReadonlyProvider]);

  //////////////////////////////////////////////////////////////////////////////
  // Load Messages
  //////////////////////////////////////////////////////////////////////////////

  const loadCommunications = useCallback(async () => {
    if (!contractInstance || isLoadingRef.current) {
      return;
    }

    isLoadingRef.current = true;
    setIsLoading(true);
    setMessage("Loading secure communications...");

    try {
      const total = await contractInstance.getTotalCommunications();
      setTotalCommunications(Number(total));

      const loadedCommunications: SecureCommunicationType[] = [];

      // Load all messages (in a real app, you'd implement pagination)
      for (let i = 1; i <= Number(total); i++) {
        try {
          const [sender, recipient, transmissionTime] = await contractInstance.getCommunicationInfo(i);
          loadedCommunications.push({
            id: i,
            sender,
            recipient,
            content: null,
            transmissionTime: Number(transmissionTime),
            isDecrypted: false,
          });
        } catch (error) {
          console.error(`Failed to load message ${i}:`, error);
        }
      }

      setCommunications(loadedCommunications);
      setMessage(`Loaded ${loadedCommunications.length} secure communications`);
    } catch (error) {
      setMessage("Failed to load secure communications");
      console.error("Load messages error:", error);
    } finally {
      isLoadingRef.current = false;
      setIsLoading(false);
    }
  }, [contractInstance]);

  // Auto load messages when contract is available
  useEffect(() => {
    loadCommunications();
  }, [loadCommunications]);

  //////////////////////////////////////////////////////////////////////////////
  // Send Love Message
  //////////////////////////////////////////////////////////////////////////////

  const transmitSecureMessage = useCallback(
    async (recipientAddress: string, messageText: string) => {
      if (isTransmittingRef.current || !instance || !ethersSigner || !cipherBoard.address) {
        return;
      }

      if (!ethers.isAddress(recipientAddress)) {
        setMessage("Invalid recipient address");
        return;
      }

      if (recipientAddress.toLowerCase() === (await ethersSigner.getAddress()).toLowerCase()) {
        setMessage("Cannot transmit communication to yourself");
        return;
      }

      const thisChainId = chainId;
      const thisCipherBoardAddress = cipherBoard.address;
      const thisEthersSigner = ethersSigner;
      const thisContract = new ethers.Contract(
        thisCipherBoardAddress,
        cipherBoard.abi,
        thisEthersSigner
      );

      isTransmittingRef.current = true;
      setIsTransmitting(true);
      setMessage("Preparing to transmit secure message...");

      const run = async () => {
        const isStale = () =>
          thisCipherBoardAddress !== cipherBoardRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Convert message text to bytes and then to number for encryption
          const messageBytes = ethers.toUtf8Bytes(messageText);
          const messageValue = BigInt(ethers.hexlify(messageBytes));

          setMessage("Creating encrypted input...");

          const input = instance.createEncryptedInput(
            thisCipherBoardAddress,
            thisEthersSigner.address
          );
          input.add256(messageValue);

          // CPU-intensive operation
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Transmitting secure message to blockchain...");

          const tx: ethers.TransactionResponse = await thisContract.transmitSecureMessage(
            recipientAddress,
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Transaction submitted: ${tx.hash}`);

          const receipt = await tx.wait();

          setMessage(`Secure message transmitted! Block: ${receipt?.blockNumber}`);

          // Reload messages to include the new one
          await loadCommunications();

        } catch (error) {
          setMessage("Failed to transmit secure message");
          console.error("Transmit secure message error:", error);
        } finally {
          isTransmittingRef.current = false;
          setIsTransmitting(false);
        }
      };

      await run();
    },
    [
      instance,
      ethersSigner,
      cipherBoard.address,
      cipherBoard.abi,
      chainId,
      sameChain,
      sameSigner,
      loadCommunications,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Message
  //////////////////////////////////////////////////////////////////////////////

  const decryptCommunication = useCallback(
    async (messageId: number) => {
      if (isDecryptingRef.current || !instance || !ethersSigner) {
        return;
      }

      const message = communications.find(m => m.id === messageId);
      if (!message) {
        setMessage("Message not found");
        return;
      }

      // Only recipient can decrypt
      const userAddress = await ethersSigner.getAddress();
      if (message.recipient.toLowerCase() !== userAddress.toLowerCase()) {
        setMessage("PERMISSION_DENIED:Only the recipient can decrypt this communication");
        return;
      }

      const thisChainId = chainId;
      const thisEthersSigner = ethersSigner;
      const thisCipherBoardAddress = cipherBoard.address;

      if (!thisCipherBoardAddress) {
        setMessage("Contract address not available");
        return;
      }

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting message ${messageId}...`);

      const run = async () => {
        const isStale = () =>
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig: FhevmDecryptionSignature | null =
            await FhevmDecryptionSignature.loadOrSign(
              instance,
              [thisCipherBoardAddress as `0x${string}`],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Calling FHEVM decryption...");

          const contract = new ethers.Contract(
            thisCipherBoardAddress,
            cipherBoard.abi,
            ethersReadonlyProvider
          );

          const encryptedContent = await contract.getCommunicationContent(messageId);

          // Get handle from euint256 object
          const handle = encryptedContent.handle || encryptedContent.toString();

          const res = await instance.userDecrypt(
            [{ handle: handle, contractAddress: thisCipherBoardAddress }],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          // Convert decrypted bytes back to string
          const decryptedValue = res[handle];
          if (typeof decryptedValue === 'bigint') {
            const hexString = ethers.toBeHex(decryptedValue);
            const messageText = ethers.toUtf8String(hexString);
            setDecryptedContents(prev => new Map(prev.set(messageId, messageText)));
            setCommunications(prev => prev.map(m =>
              m.id === messageId ? { ...m, content: messageText, isDecrypted: true } : m
            ));
            setMessage(`Communication ${messageId} decrypted successfully!`);
          } else {
            setMessage("Failed to decrypt communication: invalid format");
          }

        } catch (error) {
          setMessage(`Failed to decrypt communication ${messageId}`);
          console.error("Decrypt communication error:", error);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      await run();
    },
    [
      instance,
      ethersSigner,
      ethersReadonlyProvider,
      fhevmDecryptionSignatureStorage,
      cipherBoard.address,
      cipherBoard.abi,
      communications,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: cipherBoard.address,
    isDeployed,
    communications,
    totalCommunications,
    isLoading,
    isTransmitting,
    isDecrypting,
    message,
    transmitSecureMessage,
    decryptCommunication,
    loadCommunications,
  };
};
